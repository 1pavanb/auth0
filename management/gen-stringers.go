// Copyright 2017 The go-github AUTHORS. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Generates string method for structs.
//
// This code is a modified version of https://github.com/google/go-github and
// it's subject to its licence.
package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
	"time"
)

const suffix = "_stringers.go"

var (
	verbose = flag.Bool("v", false, "Print verbose log messages")

	blacklist = []string{
		`Management`,
		`.*Manager$`,
	}
)

func logf(fmt string, args ...interface{}) {
	if *verbose {
		log.Printf(fmt, args...)
	}
}

func main() {
	flag.Parse()
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, ".", filter, 0)
	if err != nil {
		log.Fatal(err)
		return
	}

	for pkgName, pkg := range pkgs {
		t := &templateData{
			File:    pkgName + suffix,
			Year:    time.Now().Year(),
			Package: pkgName,
			Imports: map[string]string{},
		}
		for File, f := range pkg.Files {
			logf("Processing %v...", File)
			if err := t.process(f); err != nil {
				log.Fatal(err)
			}
		}
		if err := t.dump(); err != nil {
			log.Fatal(err)
		}
	}
	logf("Done.")
}

func filter(f os.FileInfo) bool {
	return !strings.HasSuffix(f.Name(), "_test.go") && !strings.HasSuffix(f.Name(), suffix)
}

type templateData struct {
	File      string
	Year      int
	Package   string
	Imports   map[string]string
	Stringers []*stringer
}

func (t *templateData) process(f *ast.File) error {
	for _, decl := range f.Decls {
		gd, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		specLoop:
		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			// Skip unexported identifiers.
			if !ts.Name.IsExported() {
				logf("Struct %v is unexported; skipping.", ts.Name)
				continue
			}
			// Check if the struct is blacklisted.
			for _, pattern := range blacklist {
				match, err := regexp.Match(pattern, []byte(ts.Name.String()))
				if err != nil {
					return err
				}
				if match {
					logf("Struct %v is blacklisted; skipping.", ts.Name)
					continue specLoop
				}
			}
			if _, ok := ts.Type.(*ast.StructType); !ok {
				continue
			}
			t.add(ts.Name.String())
		}
	}
	return nil
}

func (t *templateData) add(receiverType string) {
	t.Stringers = append(t.Stringers, &stringer{
		ReceiverVar:  strings.ToLower(receiverType[:1]),
		ReceiverType: receiverType,
	})
}

func (t *templateData) dump() error {
	if len(t.Stringers) == 0 {
		logf("No Stringers for %v; skipping.", t.File)
		return nil
	}

	tpl := template.Must(template.New("source").Parse(source))

	var buf bytes.Buffer
	if err := tpl.Execute(&buf, t); err != nil {
		return err
	}
	clean, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	logf("Writing %v...", t.File)
	return ioutil.WriteFile(t.File, clean, 0644)
}

type stringer struct {
	ReceiverVar  string // The one-letter variable name to match the ReceiverType.
	ReceiverType string
}

const source = `// Code generated by gen-accessors; DO NOT EDIT.

package {{.Package}}
{{with .Imports}}
import (
  {{- range . -}}
  "{{.}}"
  {{end -}}
)
{{end}}
{{range .Stringers}}
// String returns a string representation of {{.ReceiverType}}.
func ({{.ReceiverVar}} *{{.ReceiverType}}) String() string {
  return Stringify({{.ReceiverVar}})
}
{{end}}
`
